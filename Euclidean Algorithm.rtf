{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf460
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 *----------------------------------------------------------------------\
* Programmer: Chad Krauthamer\
* Class Account: masc0759\
* Assignment or Title: Program #4\
* Filename: prog4.s\
* Date completed:  5/05/16\
*----------------------------------------------------------------------\
* Problem statement: Reduce a fraction with euclidean algorithm\
* Input: User\
* Output: ,outfile*\
* Error conditions tested: invalid fraction\
* Included files: getInput.h68, reduce.s, GCD.s, prog4.s\
* Method and/or pseudocode: euclidean algorithm\
* References: TA\
*----------------------------------------------------------------------\
*\
        ORG     $0\
        DC.L    $3000           * Stack pointer value after a reset\
        DC.L    start           * Program counter value after a reset\
        ORG     $3000           * Start at location 3000 Hex\
*\
*----------------------------------------------------------------------\
*\
#minclude /home/ma/cs237/bsvc/iomacs.s\
#minclude /home/ma/cs237/bsvc/evtmacs.s\
*\
*----------------------------------------------------------------------\
*\
* Register use:	A0 is used for printing in prog4\
*		A0 is used as an address register in reduce and GCD\
*		A1 is used as an address register in reduce and GCD\
*		D0 is used as a data register in reduce and GCD\
*		D1 is used as a data register in reduce and GCD\
*		D2 is used as a data register in reduce and GCD\
*\
*----------------------------------------------------------------------\
*\
input:	EQU	$6000\
reduce:	EQU	$8000\
start:  initIO 				* Initialize (required for I/O)\
	setEVT			* Error handling routines\
*	initF				* For floating point macros only	\
\
	lineout		prompt		*print program title\
	pea		den		*push denominator onto stack\
	pea		num		*push	numerator onto stack\
	pea		prompt1	*push prompt onto stack\
again:	jsr		input		*jump to getInput\
	\
	bvc		done		*branch to done if v clear\
	lineout		error		*print error prompt\
	bra		again		*recurse to getInput\
	\
done:	adda.l		#12,SP		*pop garbage\
	pea		den		*push denominator onto stack\
	pea 		num		*push numerator onto stack\
	jsr		reduce		*jump to reduce\
	adda.l		#8,SP		*pop garbage\
		\
	lea		frac,A0		\
	move.w	num,D0		\
	andi.l		#$0000FFFF,D0	\
	cvt2a		(A0),#5		\
	stripp		(A0),#5\
	adda.l		D0,A0\
	move.b		#'/',(A0)+\
	move.w	den,D0\
	andi.l		#$0000FFFF,D0\
	cvt2a		(A0),#5\
	stripp		(A0),#5\
	adda.l		D0,A0\
	clr.b		(A0)\
	lineout		ans\
\
        break                   * Terminate execution\
*\
*----------------------------------------------------------------------\
*       Storage declarations\
\
prompt:	dc.b	'Program #4, Chad Krauthamer, masc0759',0\
prompt1:dc.b	'Enter a fraction to reduce: ',0\
error:	dc.b	'Invalid fraction, please try again',0\
num:	ds.w	1\
den:	ds.w	1\
ans:	dc.b	'The reduced fraction is '\
frac:	ds.b	15\
\
	end\
\
\
\
\
\
\
Reduce.s:\
\
	ORG 		$8000\
GCD:	EQU		$7000\
\
reduce:\
	link		A6,#0		*save return address\
	movem.l	A0/A1,-(SP)	*push adress register onto stack\
	movea.l	8(A6),A0	*get contents off stack\
	movea.l	12(A6),A1\
	move.w	(A0),-(SP)	*push contents onto stack\
	move.w	(A1),-(SP)\
	jsr		GCD		*jump to GCD\
	adda.l		#4,SP		*pop garbage\
	\
	\
	move.w	(A0),D1	*move contents to data register\
	ext.l		D1		*extend contents for division\
	move.w	(A1),D2\
	ext.l		D2\
	divu		D0,D1		*num/GCD\
	divu		D0,D2		*den/GCD\
	move.w	D1,(A0)	*copy reduced num to (A0)\
	move.w	D2,(A1)	*copy reduced den to (A1)\
	\
	movem.l	(SP)+,A0/A1	*pop adress registers off stack\
	unlk		A6		\
	rts\
	end\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
GCD.s:\
\
	ORG		$7000\
GCD:\
	link		A6,#0		*save return address\
	movem.l	D1-D2,-(SP)	*copy data registers\
	move.w	8(A6),D1	*A\
	move.w	10(A6),D2	*B\
	\
	tst.w		D2		*tst if (b==0)\
	bne		loop		*branch if not 0\
	move.w  	D1,D0		*return b\
	bra		done	\
loop:	\
	ext.l		D1		*extend D1 for divu\
	divu.w		D2,D1		*a/b\
	swap		D1		*swap for a % b\
	ext.l		D1		\
	move.w	D1,-(SP)	*push (a % b) onto stack\
	move.w	D2,-(SP)	*push b onto stack\
	jsr		GCD		*recurse to GCD\
	adda.l		#4,SP		*pop garbage\
	\
done:		\
	movem.l	(SP)+,D1-D2	*pop D1-D2 off stack\
	unlk		A6\
	rts\
	end\
\
\
}